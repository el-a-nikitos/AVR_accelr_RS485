//---------Библиотека для работы с часами реального времени PCF8583-----------
//       ==== автор Шутов Максим [Zlodey], г.Вельск, Ноябрь 2013 ====
//           ===============версия 09-11-2013===================
//----------------------------------------------------------------------------





//===============================================================
//	         адреса чтения и записи PCF8583
//===============================================================
// адреса чтения и записи микросхемы PCF8583
#define READ_PCF	0xA1	//Адрес для чтения PCF8583
#define WRITE_PCF	0xA0	//Адрес для записи PCF8583






























//===============================================================
//             Служебные переменные и библиотеки
//===============================================================
volatile unsigned char PCF_hour=0;		// время, часы (от 0 до 23, защита от переполнения при записи и чтении)
volatile unsigned char PCF_min=0;		// время, минуты (от 0 до 59, защита от переполнения при записи и чтении)
volatile unsigned char PCF_sec=0;		// время, секунды (только для чтения, при записи сбрасываются в 00)
volatile unsigned char PCF_day=0;		// день (от 1 до 31, защита от переполнения при записи и чтении)
volatile unsigned char PCF_weekday=0;	// день недели (0-понедельник; 6-воскресенье, защита от переполнения при записи и чтении)
volatile unsigned char PCF_month=0;		// месяц (от 1 до 12, защита от переполнения при записи и чтении)
volatile unsigned char PCF_year=0;		// год (0-високосный; 1,2,3-невисокосные, защита от переполнения при записи и чтении)
volatile unsigned char PCF_data_ram_1;	// Данные (ОЗУ PCF8583), байт 1
volatile unsigned char PCF_data_ram_2;	// Данные (ОЗУ PCF8583), байт 2
volatile unsigned char PCF_data_ram_3;	// Данные (ОЗУ PCF8583), байт 3
volatile unsigned char PCF_data_ram_4;	// Данные (ОЗУ PCF8583), байт 4
volatile unsigned char PCF_data_ram_5;	// Данные (ОЗУ PCF8583), байт 5
// если > 0 значит из микросхемы PCF8583T считываются нереальные цифры (например, 65 часов 136 минут)
volatile unsigned char PCF_overflow=0;	// Если > 0, значит возникло переполнение. Например, если микросхема выдаёт 37 часов 74 минуты 86 секунд., или выдаёт дату 54 декабря или 10-й день недели







//*************************************************************
//ПРОТОТИПЫ ФУНКЦИЙ
void PCF_read_hh_mm_ss (void);	//считывает время и дату, и раскидывает их по переменным
void PCF_write_hh_mm_ss (void); //записывает время и дату из переменных  
void PCF_read_ram (void);		//считывает 5 байт пользовательской RAM памяти, и раскидывает их по переменным
void PCF_write_ram (void);		//записывает 5 байт пользовательской RAM памяти из переменных  













//======================================================================================================================================================
//   Считывает из PCF8583:  время в переменные "PCF_hour", "PCF_min", "PCF_sec" и дату в переменные "PCF_day", "PCF_weekday", "PCF_month", "PCF_year"
//======================================================================================================================================================
void PCF_read_hh_mm_ss (void)	{	
	unsigned char i; // временная переменная для перевода из BCD кодировки
	//чтение времени из PCF8583
	//PCF_hour=0;
	//PCF_min=0;
	//PCF_sec=0;
	
	i2c_restart_cond();
	i2c_send_byte (WRITE_PCF);  // адрес записи
	i2c_send_byte (0x02);		// адрес секунд и десятков секунд (при дальнейшем чтении, адрес инкрементируется автоматически)

	i2c_restart_cond();			// повторный старт
	i2c_send_byte(READ_PCF);	// адрес чтения
		
	i=i2c_get_byte(0);												// чтение секунды
	PCF_sec=(((i & 0b11110000) >> 4 ) * 10 ) + ((i & 0b00001111));  // перевод из BCD в BIN и передача в переменную "sec"
	
	i=i2c_get_byte(0);												// чтение минуты
	PCF_min=(((i & 0b11110000) >> 4 ) * 10 ) + ((i & 0b00001111));  // перевод из BCD в BIN и передача в переменную "min"
	
	i=i2c_get_byte(0);												// чтение часы
	PCF_hour=(((i & 0b11110000) >> 4 ) * 10 ) + ((i & 0b00001111)); // перевод из BCD в BIN и передача в переменную "hour"
	
	i=i2c_get_byte(0);												// чтение год/день
	PCF_day=(((i & 0b00110000) >> 4 ) * 10 ) + ((i & 0b00001111));	// день
	PCF_year=(i >> 6);												// год
	
	i=i2c_get_byte(1);												// чтение неделя/месяц
	PCF_month=(((i & 0b00010000) >> 4 ) * 10 ) + ((i & 0b00001111));// месяц
	PCF_weekday=(i >> 5);											//день недели
	
	i2c_stop_cond();
	
	// проверка данных на правильность
	PCF_overflow=0;     													 // сброс флага переполнения
	if (PCF_hour>23) { PCF_hour=0; PCF_min=0; PCF_sec=0; PCF_overflow++; };  // мы не можем использовать ЧЧ больше чем 23, если по какой-то причине с PCF8583 считалось больше 23 часов, то выдаём переполнение
	if (PCF_min>59)  { PCF_hour=0; PCF_min=0; PCF_sec=0; PCF_overflow++; };  // мы не можем использовать ММ больше чем 59, если по какой-то причине с PCF8583 считалось больше 59 минут, то выдаём переполнение
	if (PCF_sec>59)  { PCF_hour=0; PCF_min=0; PCF_sec=0; PCF_overflow++; };  // мы не можем использовать СС больше чем 59, если по какой-то причине с PCF8583 считалось больше 59 секунд, то выдаём переполнение
	if (PCF_day>31)		 { PCF_day=1; PCF_weekday=0; PCF_month=1; PCF_year=0; PCF_overflow++; };  // мы не можем использовать день больше чем 31, если по какой-то причине с PCF8583 считалось день больше 31, то выдаём переполнение
	if (PCF_month>12)	 { PCF_day=1; PCF_weekday=0; PCF_month=1; PCF_year=0; PCF_overflow++; };  // мы не можем использовать месяц больше чем 13, если по какой-то причине с PCF8583 считалось месяц больше 12, то выдаём переполнение
	if (PCF_weekday>6)	 { PCF_day=1; PCF_weekday=0; PCF_month=1; PCF_year=0; PCF_overflow++; };  // мы не можем использовать день недели больше чем 6, если по какой-то причине с PCF8583 считалось день недели больше 6, то выдаём переполнение
	if (PCF_year>3)		 { PCF_day=1; PCF_weekday=0; PCF_month=1; PCF_year=0; PCF_overflow++; };  // мы не можем использовать год больше чем 3, если по какой-то причине с PCF8583 считалось год больше 3, то выдаём переполнение
}







//======================================================================================================================================================
//  Записывает в PCF8583: время из переменных "PCF_hour", "PCF_min", "PCF_sec" и дату из переменных "PCF_day", "PCF_weekday", "PCF_month", "PCF_year" 
//======================================================================================================================================================
void PCF_write_hh_mm_ss (void)	{	
	unsigned char i; // временная переменная для перевода в BCD кодировку
 
	// перед записью проверяем корректность входных данных
	if (PCF_hour>23) PCF_hour=0;		// мы не можем использовать ЧЧ больше чем 23
	if (PCF_min>59) PCF_min=0;			// мы не можем использовать ММ больше чем 59
	if (PCF_sec>59) PCF_sec=0;			// мы не можем использовать СС больше чем 59
	if (PCF_day>31) PCF_day=0;			// мы не можем использовать день больше чем 31
	if (PCF_weekday>6) PCF_weekday=0;	// день недели только с ПН (0) до ВС (6)
	if (PCF_month>12) PCF_month=0;		// мы не можем использовать месяц больше чем 12
	if (PCF_year>3) PCF_year=0;			// год только от 0 (високосный) до 3 (1,2,3 невисокосные)
 
	i2c_restart_cond();
	i2c_send_byte (WRITE_PCF);	// адрес записи
	i2c_send_byte (0x02);		// адрес секунд и десятков секунд (при дальнейшей записи, адрес инкрементируется автоматически)
	
	i2c_send_byte (0);			// сброс десятков секунд/секунд в 00
	
	// перед записью в микросхему часов, надо перевести время и дату в формат BCD
	div_t res = div (PCF_min, 10) ;	// делим минуты на 10, частное записывается в переменную "res.quot", а остаток в переменную "res.rem"
	i=(res.quot << 4) | res.rem;	// перевод "min"  из BIN в BCD и передача в PCF8583
	i2c_send_byte (i);				// запись десятков минут/минут
	
	res = div (PCF_hour, 10) ;		// делим час на 10, частное записывается в переменную "res.quot", а остаток в переменную "res.rem"
	i=(res.quot << 4) | res.rem;	// перевод "hour" из BIN в BCD и передача в PCF8583
	i2c_send_byte (i);				// запись десятков часов/часов
	
	res = div (PCF_day, 10) ;		// делим день на 10, частное записывается в переменную "res.quot", а остаток в переменную "res.rem"
	i=(res.quot << 4) | res.rem;	// день
	i=i | (PCF_year << 6);			// добавляем год
	i2c_send_byte (i);				// запись год/день
	
	res = div (PCF_month, 10) ;		// делим месяц на 10, частное записывается в переменную "res.quot", а остаток в переменную "res.rem"
	i=(res.quot << 4) | res.rem;	// месяц
	i=i | (PCF_weekday << 5);		// добавляем день недели
	i2c_send_byte (i);				// запись день недели/месяц

	i2c_stop_cond();
}


















//================================================================================
//          Считать 5 байт из ОЗУ PCF8583 в переменные "PCF_data_ram_1...5"
//================================================================================
void PCF_read_ram (void)	{
	i2c_restart_cond();
	i2c_send_byte (WRITE_PCF);	// адрес записи
	i2c_send_byte (0x10);	    // первая ячейка RAM PCF8583 (при дальнейшем чтении, адрес инкрементируется автоматически)
	i2c_restart_cond();			// повторный старт
	i2c_send_byte(READ_PCF);	// адрес чтения
	
	PCF_data_ram_1=i2c_get_byte(0); // читаем байт 1
	PCF_data_ram_2=i2c_get_byte(0); // читаем байт 2
	PCF_data_ram_3=i2c_get_byte(0); // читаем байт 3
	PCF_data_ram_4=i2c_get_byte(0); // читаем байт 4
	PCF_data_ram_5=i2c_get_byte(1); // читаем байт 5
	
	i2c_stop_cond();
}









//============================================================================
//      Записать 5 байт в ОЗУ PCF8583 из переменных "PCF_data_ram_1...5"
//============================================================================
void PCF_write_ram (void)	{
	i2c_restart_cond();
	i2c_send_byte (WRITE_PCF);	    // адрес записи
	i2c_send_byte (0x10);			// первая ячейка RAM PCF8583 (при дальнейшем чтении, адрес инкрементируется автоматически)

	i2c_send_byte (PCF_data_ram_1);		// записываем байт 1
	i2c_send_byte (PCF_data_ram_2);		// записываем байт 2
	i2c_send_byte (PCF_data_ram_3);		// записываем байт 3
	i2c_send_byte (PCF_data_ram_4);		// записываем байт 4
	i2c_send_byte (PCF_data_ram_5);		// записываем байт 5
	
	i2c_stop_cond();
}








